// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "simulationfile.h"

// Vec3_t
//

Vec3_t::
Vec3_t ()
: ::xsd::cxx::tree::list< ::xml_schema::decimal, char, ::xsd::cxx::tree::schema_type::decimal > ( ::xml_schema::flags (0), this)
{
}

Vec3_t::
Vec3_t (size_type n, const ::xml_schema::decimal& x)
: ::xsd::cxx::tree::list< ::xml_schema::decimal, char, ::xsd::cxx::tree::schema_type::decimal > (n, x, this)
{
}

Vec3_t::
Vec3_t (const Vec3_t& o,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::decimal, char, ::xsd::cxx::tree::schema_type::decimal > (o, f, this)
{
}

// dim3_t
//

dim3_t::
dim3_t ()
: ::xsd::cxx::tree::list< ::xml_schema::int_, char > ( ::xml_schema::flags (0), this)
{
}

dim3_t::
dim3_t (size_type n, const ::xml_schema::int_& x)
: ::xsd::cxx::tree::list< ::xml_schema::int_, char > (n, x, this)
{
}

dim3_t::
dim3_t (const dim3_t& o,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::int_, char > (o, f, this)
{
}

// List_t
// 


// conditions_t
// 

const conditions_t::condition_sequence& conditions_t::
condition () const
{
  return this->condition_;
}

conditions_t::condition_sequence& conditions_t::
condition ()
{
  return this->condition_;
}

void conditions_t::
condition (const condition_sequence& s)
{
  this->condition_ = s;
}


// LinkedCell_t
// 

const LinkedCell_t::sizeofdomainX_type& LinkedCell_t::
sizeofdomainX () const
{
  return this->sizeofdomainX_.get ();
}

LinkedCell_t::sizeofdomainX_type& LinkedCell_t::
sizeofdomainX ()
{
  return this->sizeofdomainX_.get ();
}

void LinkedCell_t::
sizeofdomainX (const sizeofdomainX_type& x)
{
  this->sizeofdomainX_.set (x);
}

const LinkedCell_t::sizeofdomainY_type& LinkedCell_t::
sizeofdomainY () const
{
  return this->sizeofdomainY_.get ();
}

LinkedCell_t::sizeofdomainY_type& LinkedCell_t::
sizeofdomainY ()
{
  return this->sizeofdomainY_.get ();
}

void LinkedCell_t::
sizeofdomainY (const sizeofdomainY_type& x)
{
  this->sizeofdomainY_.set (x);
}

const LinkedCell_t::sizeofdomainZ_type& LinkedCell_t::
sizeofdomainZ () const
{
  return this->sizeofdomainZ_.get ();
}

LinkedCell_t::sizeofdomainZ_type& LinkedCell_t::
sizeofdomainZ ()
{
  return this->sizeofdomainZ_.get ();
}

void LinkedCell_t::
sizeofdomainZ (const sizeofdomainZ_type& x)
{
  this->sizeofdomainZ_.set (x);
}

const LinkedCell_t::cutoff_radius_type& LinkedCell_t::
cutoff_radius () const
{
  return this->cutoff_radius_.get ();
}

LinkedCell_t::cutoff_radius_type& LinkedCell_t::
cutoff_radius ()
{
  return this->cutoff_radius_.get ();
}

void LinkedCell_t::
cutoff_radius (const cutoff_radius_type& x)
{
  this->cutoff_radius_.set (x);
}

const LinkedCell_t::offset_type& LinkedCell_t::
offset () const
{
  return this->offset_.get ();
}

LinkedCell_t::offset_type& LinkedCell_t::
offset ()
{
  return this->offset_.get ();
}

void LinkedCell_t::
offset (const offset_type& x)
{
  this->offset_.set (x);
}

void LinkedCell_t::
offset (::std::auto_ptr< offset_type > x)
{
  this->offset_.set (x);
}

const LinkedCell_t::conditions_optional& LinkedCell_t::
conditions () const
{
  return this->conditions_;
}

LinkedCell_t::conditions_optional& LinkedCell_t::
conditions ()
{
  return this->conditions_;
}

void LinkedCell_t::
conditions (const conditions_type& x)
{
  this->conditions_.set (x);
}

void LinkedCell_t::
conditions (const conditions_optional& x)
{
  this->conditions_ = x;
}

void LinkedCell_t::
conditions (::std::auto_ptr< conditions_type > x)
{
  this->conditions_.set (x);
}


// Membrane_t
// 

const Membrane_t::pull_iterations_type& Membrane_t::
pull_iterations () const
{
  return this->pull_iterations_.get ();
}

Membrane_t::pull_iterations_type& Membrane_t::
pull_iterations ()
{
  return this->pull_iterations_.get ();
}

void Membrane_t::
pull_iterations (const pull_iterations_type& x)
{
  this->pull_iterations_.set (x);
}


// algorithm_t
// 

const algorithm_t::List_optional& algorithm_t::
List () const
{
  return this->List_;
}

algorithm_t::List_optional& algorithm_t::
List ()
{
  return this->List_;
}

void algorithm_t::
List (const List_type& x)
{
  this->List_.set (x);
}

void algorithm_t::
List (const List_optional& x)
{
  this->List_ = x;
}

void algorithm_t::
List (::std::auto_ptr< List_type > x)
{
  this->List_.set (x);
}

const algorithm_t::LinkedCell_optional& algorithm_t::
LinkedCell () const
{
  return this->LinkedCell_;
}

algorithm_t::LinkedCell_optional& algorithm_t::
LinkedCell ()
{
  return this->LinkedCell_;
}

void algorithm_t::
LinkedCell (const LinkedCell_type& x)
{
  this->LinkedCell_.set (x);
}

void algorithm_t::
LinkedCell (const LinkedCell_optional& x)
{
  this->LinkedCell_ = x;
}

void algorithm_t::
LinkedCell (::std::auto_ptr< LinkedCell_type > x)
{
  this->LinkedCell_.set (x);
}

const algorithm_t::Membrane_optional& algorithm_t::
Membrane () const
{
  return this->Membrane_;
}

algorithm_t::Membrane_optional& algorithm_t::
Membrane ()
{
  return this->Membrane_;
}

void algorithm_t::
Membrane (const Membrane_type& x)
{
  this->Membrane_.set (x);
}

void algorithm_t::
Membrane (const Membrane_optional& x)
{
  this->Membrane_ = x;
}

void algorithm_t::
Membrane (::std::auto_ptr< Membrane_type > x)
{
  this->Membrane_.set (x);
}


// SLJ_t
// 

const SLJ_t::factor_optional& SLJ_t::
factor () const
{
  return this->factor_;
}

SLJ_t::factor_optional& SLJ_t::
factor ()
{
  return this->factor_;
}

void SLJ_t::
factor (const factor_type& x)
{
  this->factor_.set (x);
}

void SLJ_t::
factor (const factor_optional& x)
{
  this->factor_ = x;
}


// potentialforce_t
// 

const potentialforce_t::LJ_optional& potentialforce_t::
LJ () const
{
  return this->LJ_;
}

potentialforce_t::LJ_optional& potentialforce_t::
LJ ()
{
  return this->LJ_;
}

void potentialforce_t::
LJ (const LJ_type& x)
{
  this->LJ_.set (x);
}

void potentialforce_t::
LJ (const LJ_optional& x)
{
  this->LJ_ = x;
}

void potentialforce_t::
LJ (::std::auto_ptr< LJ_type > x)
{
  this->LJ_.set (x);
}

const potentialforce_t::Gravity_optional& potentialforce_t::
Gravity () const
{
  return this->Gravity_;
}

potentialforce_t::Gravity_optional& potentialforce_t::
Gravity ()
{
  return this->Gravity_;
}

void potentialforce_t::
Gravity (const Gravity_type& x)
{
  this->Gravity_.set (x);
}

void potentialforce_t::
Gravity (const Gravity_optional& x)
{
  this->Gravity_ = x;
}

void potentialforce_t::
Gravity (::std::auto_ptr< Gravity_type > x)
{
  this->Gravity_.set (x);
}

const potentialforce_t::SLJ_optional& potentialforce_t::
SLJ () const
{
  return this->SLJ_;
}

potentialforce_t::SLJ_optional& potentialforce_t::
SLJ ()
{
  return this->SLJ_;
}

void potentialforce_t::
SLJ (const SLJ_type& x)
{
  this->SLJ_.set (x);
}

void potentialforce_t::
SLJ (const SLJ_optional& x)
{
  this->SLJ_ = x;
}

void potentialforce_t::
SLJ (::std::auto_ptr< SLJ_type > x)
{
  this->SLJ_.set (x);
}


// params_t
// 

const params_t::dimension_type& params_t::
dimension () const
{
  return this->dimension_.get ();
}

params_t::dimension_type& params_t::
dimension ()
{
  return this->dimension_.get ();
}

void params_t::
dimension (const dimension_type& x)
{
  this->dimension_.set (x);
}

const params_t::output_type& params_t::
output () const
{
  return this->output_.get ();
}

params_t::output_type& params_t::
output ()
{
  return this->output_.get ();
}

void params_t::
output (const output_type& x)
{
  this->output_.set (x);
}

void params_t::
output (::std::auto_ptr< output_type > x)
{
  this->output_.set (x);
}

const params_t::iterationsperoutput_type& params_t::
iterationsperoutput () const
{
  return this->iterationsperoutput_.get ();
}

params_t::iterationsperoutput_type& params_t::
iterationsperoutput ()
{
  return this->iterationsperoutput_.get ();
}

void params_t::
iterationsperoutput (const iterationsperoutput_type& x)
{
  this->iterationsperoutput_.set (x);
}

const params_t::delta_t_type& params_t::
delta_t () const
{
  return this->delta_t_.get ();
}

params_t::delta_t_type& params_t::
delta_t ()
{
  return this->delta_t_.get ();
}

void params_t::
delta_t (const delta_t_type& x)
{
  this->delta_t_.set (x);
}

const params_t::t_end_type& params_t::
t_end () const
{
  return this->t_end_.get ();
}

params_t::t_end_type& params_t::
t_end ()
{
  return this->t_end_.get ();
}

void params_t::
t_end (const t_end_type& x)
{
  this->t_end_.set (x);
}

const params_t::epsilon_type& params_t::
epsilon () const
{
  return this->epsilon_.get ();
}

params_t::epsilon_type& params_t::
epsilon ()
{
  return this->epsilon_.get ();
}

void params_t::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

const params_t::sigma_type& params_t::
sigma () const
{
  return this->sigma_.get ();
}

params_t::sigma_type& params_t::
sigma ()
{
  return this->sigma_.get ();
}

void params_t::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

const params_t::brownianMotionFactor_optional& params_t::
brownianMotionFactor () const
{
  return this->brownianMotionFactor_;
}

params_t::brownianMotionFactor_optional& params_t::
brownianMotionFactor ()
{
  return this->brownianMotionFactor_;
}

void params_t::
brownianMotionFactor (const brownianMotionFactor_type& x)
{
  this->brownianMotionFactor_.set (x);
}

void params_t::
brownianMotionFactor (const brownianMotionFactor_optional& x)
{
  this->brownianMotionFactor_ = x;
}

const params_t::gravity_optional& params_t::
gravity () const
{
  return this->gravity_;
}

params_t::gravity_optional& params_t::
gravity ()
{
  return this->gravity_;
}

void params_t::
gravity (const gravity_type& x)
{
  this->gravity_.set (x);
}

void params_t::
gravity (const gravity_optional& x)
{
  this->gravity_ = x;
}

const params_t::iterationsTillThermostatApplication_optional& params_t::
iterationsTillThermostatApplication () const
{
  return this->iterationsTillThermostatApplication_;
}

params_t::iterationsTillThermostatApplication_optional& params_t::
iterationsTillThermostatApplication ()
{
  return this->iterationsTillThermostatApplication_;
}

void params_t::
iterationsTillThermostatApplication (const iterationsTillThermostatApplication_type& x)
{
  this->iterationsTillThermostatApplication_.set (x);
}

void params_t::
iterationsTillThermostatApplication (const iterationsTillThermostatApplication_optional& x)
{
  this->iterationsTillThermostatApplication_ = x;
}

const params_t::initialTemperature_optional& params_t::
initialTemperature () const
{
  return this->initialTemperature_;
}

params_t::initialTemperature_optional& params_t::
initialTemperature ()
{
  return this->initialTemperature_;
}

void params_t::
initialTemperature (const initialTemperature_type& x)
{
  this->initialTemperature_.set (x);
}

void params_t::
initialTemperature (const initialTemperature_optional& x)
{
  this->initialTemperature_ = x;
}

const params_t::targetTemperature_optional& params_t::
targetTemperature () const
{
  return this->targetTemperature_;
}

params_t::targetTemperature_optional& params_t::
targetTemperature ()
{
  return this->targetTemperature_;
}

void params_t::
targetTemperature (const targetTemperature_type& x)
{
  this->targetTemperature_.set (x);
}

void params_t::
targetTemperature (const targetTemperature_optional& x)
{
  this->targetTemperature_ = x;
}

const params_t::temperatureStepSize_optional& params_t::
temperatureStepSize () const
{
  return this->temperatureStepSize_;
}

params_t::temperatureStepSize_optional& params_t::
temperatureStepSize ()
{
  return this->temperatureStepSize_;
}

void params_t::
temperatureStepSize (const temperatureStepSize_type& x)
{
  this->temperatureStepSize_.set (x);
}

void params_t::
temperatureStepSize (const temperatureStepSize_optional& x)
{
  this->temperatureStepSize_ = x;
}

const params_t::thermodynamicaldata_optional& params_t::
thermodynamicaldata () const
{
  return this->thermodynamicaldata_;
}

params_t::thermodynamicaldata_optional& params_t::
thermodynamicaldata ()
{
  return this->thermodynamicaldata_;
}

void params_t::
thermodynamicaldata (const thermodynamicaldata_type& x)
{
  this->thermodynamicaldata_.set (x);
}

void params_t::
thermodynamicaldata (const thermodynamicaldata_optional& x)
{
  this->thermodynamicaldata_ = x;
}

void params_t::
thermodynamicaldata (::std::auto_ptr< thermodynamicaldata_type > x)
{
  this->thermodynamicaldata_.set (x);
}

const params_t::t_start_type& params_t::
t_start () const
{
  return this->t_start_.get ();
}

params_t::t_start_type& params_t::
t_start ()
{
  return this->t_start_.get ();
}

void params_t::
t_start (const t_start_type& x)
{
  this->t_start_.set (x);
}

const params_t::outputfmt_type& params_t::
outputfmt () const
{
  return this->outputfmt_.get ();
}

params_t::outputfmt_type& params_t::
outputfmt ()
{
  return this->outputfmt_.get ();
}

void params_t::
outputfmt (const outputfmt_type& x)
{
  this->outputfmt_.set (x);
}

void params_t::
outputfmt (::std::auto_ptr< outputfmt_type > x)
{
  this->outputfmt_.set (x);
}

const params_t::potentialforce_type& params_t::
potentialforce () const
{
  return this->potentialforce_.get ();
}

params_t::potentialforce_type& params_t::
potentialforce ()
{
  return this->potentialforce_.get ();
}

void params_t::
potentialforce (const potentialforce_type& x)
{
  this->potentialforce_.set (x);
}

void params_t::
potentialforce (::std::auto_ptr< potentialforce_type > x)
{
  this->potentialforce_.set (x);
}

const params_t::algorithm_type& params_t::
algorithm () const
{
  return this->algorithm_.get ();
}

params_t::algorithm_type& params_t::
algorithm ()
{
  return this->algorithm_.get ();
}

void params_t::
algorithm (const algorithm_type& x)
{
  this->algorithm_.set (x);
}

void params_t::
algorithm (::std::auto_ptr< algorithm_type > x)
{
  this->algorithm_.set (x);
}


// particle_t
// 

const particle_t::X_type& particle_t::
X () const
{
  return this->X_.get ();
}

particle_t::X_type& particle_t::
X ()
{
  return this->X_.get ();
}

void particle_t::
X (const X_type& x)
{
  this->X_.set (x);
}

void particle_t::
X (::std::auto_ptr< X_type > x)
{
  this->X_.set (x);
}

const particle_t::V_type& particle_t::
V () const
{
  return this->V_.get ();
}

particle_t::V_type& particle_t::
V ()
{
  return this->V_.get ();
}

void particle_t::
V (const V_type& x)
{
  this->V_.set (x);
}

void particle_t::
V (::std::auto_ptr< V_type > x)
{
  this->V_.set (x);
}

const particle_t::material_optional& particle_t::
material () const
{
  return this->material_;
}

particle_t::material_optional& particle_t::
material ()
{
  return this->material_;
}

void particle_t::
material (const material_type& x)
{
  this->material_.set (x);
}

void particle_t::
material (const material_optional& x)
{
  this->material_ = x;
}

void particle_t::
material (::std::auto_ptr< material_type > x)
{
  this->material_.set (x);
}


// cuboid_t
// 

const cuboid_t::X_type& cuboid_t::
X () const
{
  return this->X_.get ();
}

cuboid_t::X_type& cuboid_t::
X ()
{
  return this->X_.get ();
}

void cuboid_t::
X (const X_type& x)
{
  this->X_.set (x);
}

void cuboid_t::
X (::std::auto_ptr< X_type > x)
{
  this->X_.set (x);
}

const cuboid_t::V_type& cuboid_t::
V () const
{
  return this->V_.get ();
}

cuboid_t::V_type& cuboid_t::
V ()
{
  return this->V_.get ();
}

void cuboid_t::
V (const V_type& x)
{
  this->V_.set (x);
}

void cuboid_t::
V (::std::auto_ptr< V_type > x)
{
  this->V_.set (x);
}

const cuboid_t::N_type& cuboid_t::
N () const
{
  return this->N_.get ();
}

cuboid_t::N_type& cuboid_t::
N ()
{
  return this->N_.get ();
}

void cuboid_t::
N (const N_type& x)
{
  this->N_.set (x);
}

void cuboid_t::
N (::std::auto_ptr< N_type > x)
{
  this->N_.set (x);
}

const cuboid_t::h_type& cuboid_t::
h () const
{
  return this->h_.get ();
}

cuboid_t::h_type& cuboid_t::
h ()
{
  return this->h_.get ();
}

void cuboid_t::
h (const h_type& x)
{
  this->h_.set (x);
}

const cuboid_t::material_optional& cuboid_t::
material () const
{
  return this->material_;
}

cuboid_t::material_optional& cuboid_t::
material ()
{
  return this->material_;
}

void cuboid_t::
material (const material_type& x)
{
  this->material_.set (x);
}

void cuboid_t::
material (const material_optional& x)
{
  this->material_ = x;
}

void cuboid_t::
material (::std::auto_ptr< material_type > x)
{
  this->material_.set (x);
}


// sphere_t
// 

const sphere_t::X_type& sphere_t::
X () const
{
  return this->X_.get ();
}

sphere_t::X_type& sphere_t::
X ()
{
  return this->X_.get ();
}

void sphere_t::
X (const X_type& x)
{
  this->X_.set (x);
}

void sphere_t::
X (::std::auto_ptr< X_type > x)
{
  this->X_.set (x);
}

const sphere_t::V_type& sphere_t::
V () const
{
  return this->V_.get ();
}

sphere_t::V_type& sphere_t::
V ()
{
  return this->V_.get ();
}

void sphere_t::
V (const V_type& x)
{
  this->V_.set (x);
}

void sphere_t::
V (::std::auto_ptr< V_type > x)
{
  this->V_.set (x);
}

const sphere_t::r_type& sphere_t::
r () const
{
  return this->r_.get ();
}

sphere_t::r_type& sphere_t::
r ()
{
  return this->r_.get ();
}

void sphere_t::
r (const r_type& x)
{
  this->r_.set (x);
}

const sphere_t::h_type& sphere_t::
h () const
{
  return this->h_.get ();
}

sphere_t::h_type& sphere_t::
h ()
{
  return this->h_.get ();
}

void sphere_t::
h (const h_type& x)
{
  this->h_.set (x);
}

const sphere_t::dimensions_type& sphere_t::
dimensions () const
{
  return this->dimensions_.get ();
}

sphere_t::dimensions_type& sphere_t::
dimensions ()
{
  return this->dimensions_.get ();
}

void sphere_t::
dimensions (const dimensions_type& x)
{
  this->dimensions_.set (x);
}

const sphere_t::material_optional& sphere_t::
material () const
{
  return this->material_;
}

sphere_t::material_optional& sphere_t::
material ()
{
  return this->material_;
}

void sphere_t::
material (const material_type& x)
{
  this->material_.set (x);
}

void sphere_t::
material (const material_optional& x)
{
  this->material_ = x;
}

void sphere_t::
material (::std::auto_ptr< material_type > x)
{
  this->material_.set (x);
}


// material_t
// 

const material_t::name_optional& material_t::
name () const
{
  return this->name_;
}

material_t::name_optional& material_t::
name ()
{
  return this->name_;
}

void material_t::
name (const name_type& x)
{
  this->name_.set (x);
}

void material_t::
name (const name_optional& x)
{
  this->name_ = x;
}

void material_t::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const material_t::epsilon_optional& material_t::
epsilon () const
{
  return this->epsilon_;
}

material_t::epsilon_optional& material_t::
epsilon ()
{
  return this->epsilon_;
}

void material_t::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

void material_t::
epsilon (const epsilon_optional& x)
{
  this->epsilon_ = x;
}

const material_t::sigma_optional& material_t::
sigma () const
{
  return this->sigma_;
}

material_t::sigma_optional& material_t::
sigma ()
{
  return this->sigma_;
}

void material_t::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

void material_t::
sigma (const sigma_optional& x)
{
  this->sigma_ = x;
}

const material_t::mass_optional& material_t::
mass () const
{
  return this->mass_;
}

material_t::mass_optional& material_t::
mass ()
{
  return this->mass_;
}

void material_t::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

void material_t::
mass (const mass_optional& x)
{
  this->mass_ = x;
}


// data_t
// 

const data_t::particle_sequence& data_t::
particle () const
{
  return this->particle_;
}

data_t::particle_sequence& data_t::
particle ()
{
  return this->particle_;
}

void data_t::
particle (const particle_sequence& s)
{
  this->particle_ = s;
}

const data_t::inputfile_sequence& data_t::
inputfile () const
{
  return this->inputfile_;
}

data_t::inputfile_sequence& data_t::
inputfile ()
{
  return this->inputfile_;
}

void data_t::
inputfile (const inputfile_sequence& s)
{
  this->inputfile_ = s;
}

const data_t::cuboid_sequence& data_t::
cuboid () const
{
  return this->cuboid_;
}

data_t::cuboid_sequence& data_t::
cuboid ()
{
  return this->cuboid_;
}

void data_t::
cuboid (const cuboid_sequence& s)
{
  this->cuboid_ = s;
}

const data_t::sphere_sequence& data_t::
sphere () const
{
  return this->sphere_;
}

data_t::sphere_sequence& data_t::
sphere ()
{
  return this->sphere_;
}

void data_t::
sphere (const sphere_sequence& s)
{
  this->sphere_ = s;
}

const data_t::material_sequence& data_t::
material () const
{
  return this->material_;
}

data_t::material_sequence& data_t::
material ()
{
  return this->material_;
}

void data_t::
material (const material_sequence& s)
{
  this->material_ = s;
}


// simulationfile_t
// 

const simulationfile_t::params_type& simulationfile_t::
params () const
{
  return this->params_.get ();
}

simulationfile_t::params_type& simulationfile_t::
params ()
{
  return this->params_.get ();
}

void simulationfile_t::
params (const params_type& x)
{
  this->params_.set (x);
}

void simulationfile_t::
params (::std::auto_ptr< params_type > x)
{
  this->params_.set (x);
}

const simulationfile_t::data_type& simulationfile_t::
data () const
{
  return this->data_.get ();
}

simulationfile_t::data_type& simulationfile_t::
data ()
{
  return this->data_.get ();
}

void simulationfile_t::
data (const data_type& x)
{
  this->data_.set (x);
}

void simulationfile_t::
data (::std::auto_ptr< data_type > x)
{
  this->data_.set (x);
}


// condition
// 

const condition::value_type& condition::
value () const
{
  return this->value_.get ();
}

condition::value_type& condition::
value ()
{
  return this->value_.get ();
}

void condition::
value (const value_type& x)
{
  this->value_.set (x);
}

void condition::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}

const condition::type_optional& condition::
type () const
{
  return this->type_;
}

condition::type_optional& condition::
type ()
{
  return this->type_;
}

void condition::
type (const type_type& x)
{
  this->type_.set (x);
}

void condition::
type (const type_optional& x)
{
  this->type_ = x;
}

void condition::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


// thermodynamicaldata
// 

const thermodynamicaldata::iterationsTillCalculation_type& thermodynamicaldata::
iterationsTillCalculation () const
{
  return this->iterationsTillCalculation_.get ();
}

thermodynamicaldata::iterationsTillCalculation_type& thermodynamicaldata::
iterationsTillCalculation ()
{
  return this->iterationsTillCalculation_.get ();
}

void thermodynamicaldata::
iterationsTillCalculation (const iterationsTillCalculation_type& x)
{
  this->iterationsTillCalculation_.set (x);
}

const thermodynamicaldata::iterationsPerCalculation_optional& thermodynamicaldata::
iterationsPerCalculation () const
{
  return this->iterationsPerCalculation_;
}

thermodynamicaldata::iterationsPerCalculation_optional& thermodynamicaldata::
iterationsPerCalculation ()
{
  return this->iterationsPerCalculation_;
}

void thermodynamicaldata::
iterationsPerCalculation (const iterationsPerCalculation_type& x)
{
  this->iterationsPerCalculation_.set (x);
}

void thermodynamicaldata::
iterationsPerCalculation (const iterationsPerCalculation_optional& x)
{
  this->iterationsPerCalculation_ = x;
}


// outputfmt
// 

outputfmt::
outputfmt (value v)
: ::xml_schema::string (_xsd_outputfmt_literals_[v])
{
}

outputfmt::
outputfmt (const char* v)
: ::xml_schema::string (v)
{
}

outputfmt::
outputfmt (const ::std::string& v)
: ::xml_schema::string (v)
{
}

outputfmt::
outputfmt (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

outputfmt::
outputfmt (const outputfmt& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

outputfmt& outputfmt::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_outputfmt_literals_[v]);

  return *this;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// Vec3_t
//

Vec3_t::
Vec3_t (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::decimal, char, ::xsd::cxx::tree::schema_type::decimal > (e, f, this)
{
}

Vec3_t::
Vec3_t (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::decimal, char, ::xsd::cxx::tree::schema_type::decimal > (a, f, this)
{
}

Vec3_t::
Vec3_t (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::decimal, char, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, this)
{
}

Vec3_t* Vec3_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Vec3_t (*this, f, c);
}

Vec3_t::
~Vec3_t ()
{
}

// dim3_t
//

dim3_t::
dim3_t (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::int_, char > (e, f, this)
{
}

dim3_t::
dim3_t (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::int_, char > (a, f, this)
{
}

dim3_t::
dim3_t (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::int_, char > (s, e, f, this)
{
}

dim3_t* dim3_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class dim3_t (*this, f, c);
}

dim3_t::
~dim3_t ()
{
}

// List_t
//

List_t::
List_t ()
: ::xml_schema::type ()
{
}

List_t::
List_t (const List_t& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

List_t::
List_t (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f, c)
{
}

List_t::
List_t (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (a, f, c)
{
}

List_t::
List_t (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (s, e, f, c)
{
}

List_t* List_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class List_t (*this, f, c);
}

List_t::
~List_t ()
{
}

// conditions_t
//

conditions_t::
conditions_t ()
: ::xml_schema::type (),
  condition_ (::xml_schema::flags (), this)
{
}

conditions_t::
conditions_t (const conditions_t& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  condition_ (x.condition_, f, this)
{
}

conditions_t::
conditions_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  condition_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void conditions_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // condition
    //
    if (n.name () == "condition" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< condition_type > r (
        condition_traits::create (i, f, this));

      this->condition_.push_back (r);
      continue;
    }

    break;
  }
}

conditions_t* conditions_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class conditions_t (*this, f, c);
}

conditions_t::
~conditions_t ()
{
}

// LinkedCell_t
//

LinkedCell_t::
LinkedCell_t (const sizeofdomainX_type& sizeofdomainX,
              const sizeofdomainY_type& sizeofdomainY,
              const sizeofdomainZ_type& sizeofdomainZ,
              const cutoff_radius_type& cutoff_radius,
              const offset_type& offset)
: ::xml_schema::type (),
  sizeofdomainX_ (sizeofdomainX, ::xml_schema::flags (), this),
  sizeofdomainY_ (sizeofdomainY, ::xml_schema::flags (), this),
  sizeofdomainZ_ (sizeofdomainZ, ::xml_schema::flags (), this),
  cutoff_radius_ (cutoff_radius, ::xml_schema::flags (), this),
  offset_ (offset, ::xml_schema::flags (), this),
  conditions_ (::xml_schema::flags (), this)
{
}

LinkedCell_t::
LinkedCell_t (const LinkedCell_t& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  sizeofdomainX_ (x.sizeofdomainX_, f, this),
  sizeofdomainY_ (x.sizeofdomainY_, f, this),
  sizeofdomainZ_ (x.sizeofdomainZ_, f, this),
  cutoff_radius_ (x.cutoff_radius_, f, this),
  offset_ (x.offset_, f, this),
  conditions_ (x.conditions_, f, this)
{
}

LinkedCell_t::
LinkedCell_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  sizeofdomainX_ (f, this),
  sizeofdomainY_ (f, this),
  sizeofdomainZ_ (f, this),
  cutoff_radius_ (f, this),
  offset_ (f, this),
  conditions_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void LinkedCell_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // sizeofdomainX
    //
    if (n.name () == "sizeofdomainX" && n.namespace_ ().empty ())
    {
      if (!sizeofdomainX_.present ())
      {
        this->sizeofdomainX_.set (sizeofdomainX_traits::create (i, f, this));
        continue;
      }
    }

    // sizeofdomainY
    //
    if (n.name () == "sizeofdomainY" && n.namespace_ ().empty ())
    {
      if (!sizeofdomainY_.present ())
      {
        this->sizeofdomainY_.set (sizeofdomainY_traits::create (i, f, this));
        continue;
      }
    }

    // sizeofdomainZ
    //
    if (n.name () == "sizeofdomainZ" && n.namespace_ ().empty ())
    {
      if (!sizeofdomainZ_.present ())
      {
        this->sizeofdomainZ_.set (sizeofdomainZ_traits::create (i, f, this));
        continue;
      }
    }

    // cutoff_radius
    //
    if (n.name () == "cutoff_radius" && n.namespace_ ().empty ())
    {
      if (!cutoff_radius_.present ())
      {
        this->cutoff_radius_.set (cutoff_radius_traits::create (i, f, this));
        continue;
      }
    }

    // offset
    //
    if (n.name () == "offset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< offset_type > r (
        offset_traits::create (i, f, this));

      if (!offset_.present ())
      {
        this->offset_.set (r);
        continue;
      }
    }

    // conditions
    //
    if (n.name () == "conditions" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< conditions_type > r (
        conditions_traits::create (i, f, this));

      if (!this->conditions_)
      {
        this->conditions_.set (r);
        continue;
      }
    }

    break;
  }

  if (!sizeofdomainX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sizeofdomainX",
      "");
  }

  if (!sizeofdomainY_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sizeofdomainY",
      "");
  }

  if (!sizeofdomainZ_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sizeofdomainZ",
      "");
  }

  if (!cutoff_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cutoff_radius",
      "");
  }

  if (!offset_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "offset",
      "");
  }
}

LinkedCell_t* LinkedCell_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LinkedCell_t (*this, f, c);
}

LinkedCell_t::
~LinkedCell_t ()
{
}

// Membrane_t
//

Membrane_t::
Membrane_t (const pull_iterations_type& pull_iterations)
: ::xml_schema::type (),
  pull_iterations_ (pull_iterations, ::xml_schema::flags (), this)
{
}

Membrane_t::
Membrane_t (const Membrane_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  pull_iterations_ (x.pull_iterations_, f, this)
{
}

Membrane_t::
Membrane_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  pull_iterations_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Membrane_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // pull_iterations
    //
    if (n.name () == "pull_iterations" && n.namespace_ ().empty ())
    {
      if (!pull_iterations_.present ())
      {
        this->pull_iterations_.set (pull_iterations_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!pull_iterations_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "pull_iterations",
      "");
  }
}

Membrane_t* Membrane_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Membrane_t (*this, f, c);
}

Membrane_t::
~Membrane_t ()
{
}

// algorithm_t
//

algorithm_t::
algorithm_t ()
: ::xml_schema::type (),
  List_ (::xml_schema::flags (), this),
  LinkedCell_ (::xml_schema::flags (), this),
  Membrane_ (::xml_schema::flags (), this)
{
}

algorithm_t::
algorithm_t (const algorithm_t& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  List_ (x.List_, f, this),
  LinkedCell_ (x.LinkedCell_, f, this),
  Membrane_ (x.Membrane_, f, this)
{
}

algorithm_t::
algorithm_t (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  List_ (f, this),
  LinkedCell_ (f, this),
  Membrane_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void algorithm_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // List
    //
    if (n.name () == "List" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< List_type > r (
        List_traits::create (i, f, this));

      if (!this->List_)
      {
        this->List_.set (r);
        continue;
      }
    }

    // LinkedCell
    //
    if (n.name () == "LinkedCell" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LinkedCell_type > r (
        LinkedCell_traits::create (i, f, this));

      if (!this->LinkedCell_)
      {
        this->LinkedCell_.set (r);
        continue;
      }
    }

    // Membrane
    //
    if (n.name () == "Membrane" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Membrane_type > r (
        Membrane_traits::create (i, f, this));

      if (!this->Membrane_)
      {
        this->Membrane_.set (r);
        continue;
      }
    }

    break;
  }
}

algorithm_t* algorithm_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class algorithm_t (*this, f, c);
}

algorithm_t::
~algorithm_t ()
{
}

// SLJ_t
//

SLJ_t::
SLJ_t ()
: ::xml_schema::type (),
  factor_ (::xml_schema::flags (), this)
{
}

SLJ_t::
SLJ_t (const SLJ_t& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  factor_ (x.factor_, f, this)
{
}

SLJ_t::
SLJ_t (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  factor_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void SLJ_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "factor" && n.namespace_ ().empty ())
    {
      this->factor_.set (factor_traits::create (i, f, this));
      continue;
    }
  }
}

SLJ_t* SLJ_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SLJ_t (*this, f, c);
}

SLJ_t::
~SLJ_t ()
{
}

// potentialforce_t
//

potentialforce_t::
potentialforce_t ()
: ::xml_schema::type (),
  LJ_ (::xml_schema::flags (), this),
  Gravity_ (::xml_schema::flags (), this),
  SLJ_ (::xml_schema::flags (), this)
{
}

potentialforce_t::
potentialforce_t (const potentialforce_t& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  LJ_ (x.LJ_, f, this),
  Gravity_ (x.Gravity_, f, this),
  SLJ_ (x.SLJ_, f, this)
{
}

potentialforce_t::
potentialforce_t (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  LJ_ (f, this),
  Gravity_ (f, this),
  SLJ_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void potentialforce_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // LJ
    //
    if (n.name () == "LJ" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LJ_type > r (
        LJ_traits::create (i, f, this));

      if (!this->LJ_)
      {
        this->LJ_.set (r);
        continue;
      }
    }

    // Gravity
    //
    if (n.name () == "Gravity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Gravity_type > r (
        Gravity_traits::create (i, f, this));

      if (!this->Gravity_)
      {
        this->Gravity_.set (r);
        continue;
      }
    }

    // SLJ
    //
    if (n.name () == "SLJ" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SLJ_type > r (
        SLJ_traits::create (i, f, this));

      if (!this->SLJ_)
      {
        this->SLJ_.set (r);
        continue;
      }
    }

    break;
  }
}

potentialforce_t* potentialforce_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class potentialforce_t (*this, f, c);
}

potentialforce_t::
~potentialforce_t ()
{
}

// params_t
//

params_t::
params_t (const dimension_type& dimension,
          const output_type& output,
          const iterationsperoutput_type& iterationsperoutput,
          const delta_t_type& delta_t,
          const t_end_type& t_end,
          const epsilon_type& epsilon,
          const sigma_type& sigma,
          const t_start_type& t_start,
          const outputfmt_type& outputfmt,
          const potentialforce_type& potentialforce,
          const algorithm_type& algorithm)
: ::xml_schema::type (),
  dimension_ (dimension, ::xml_schema::flags (), this),
  output_ (output, ::xml_schema::flags (), this),
  iterationsperoutput_ (iterationsperoutput, ::xml_schema::flags (), this),
  delta_t_ (delta_t, ::xml_schema::flags (), this),
  t_end_ (t_end, ::xml_schema::flags (), this),
  epsilon_ (epsilon, ::xml_schema::flags (), this),
  sigma_ (sigma, ::xml_schema::flags (), this),
  brownianMotionFactor_ (::xml_schema::flags (), this),
  gravity_ (::xml_schema::flags (), this),
  iterationsTillThermostatApplication_ (::xml_schema::flags (), this),
  initialTemperature_ (::xml_schema::flags (), this),
  targetTemperature_ (::xml_schema::flags (), this),
  temperatureStepSize_ (::xml_schema::flags (), this),
  thermodynamicaldata_ (::xml_schema::flags (), this),
  t_start_ (t_start, ::xml_schema::flags (), this),
  outputfmt_ (outputfmt, ::xml_schema::flags (), this),
  potentialforce_ (potentialforce, ::xml_schema::flags (), this),
  algorithm_ (algorithm, ::xml_schema::flags (), this)
{
}

params_t::
params_t (const dimension_type& dimension,
          const output_type& output,
          const iterationsperoutput_type& iterationsperoutput,
          const delta_t_type& delta_t,
          const t_end_type& t_end,
          const epsilon_type& epsilon,
          const sigma_type& sigma,
          const t_start_type& t_start,
          const outputfmt_type& outputfmt,
          ::std::auto_ptr< potentialforce_type >& potentialforce,
          ::std::auto_ptr< algorithm_type >& algorithm)
: ::xml_schema::type (),
  dimension_ (dimension, ::xml_schema::flags (), this),
  output_ (output, ::xml_schema::flags (), this),
  iterationsperoutput_ (iterationsperoutput, ::xml_schema::flags (), this),
  delta_t_ (delta_t, ::xml_schema::flags (), this),
  t_end_ (t_end, ::xml_schema::flags (), this),
  epsilon_ (epsilon, ::xml_schema::flags (), this),
  sigma_ (sigma, ::xml_schema::flags (), this),
  brownianMotionFactor_ (::xml_schema::flags (), this),
  gravity_ (::xml_schema::flags (), this),
  iterationsTillThermostatApplication_ (::xml_schema::flags (), this),
  initialTemperature_ (::xml_schema::flags (), this),
  targetTemperature_ (::xml_schema::flags (), this),
  temperatureStepSize_ (::xml_schema::flags (), this),
  thermodynamicaldata_ (::xml_schema::flags (), this),
  t_start_ (t_start, ::xml_schema::flags (), this),
  outputfmt_ (outputfmt, ::xml_schema::flags (), this),
  potentialforce_ (potentialforce, ::xml_schema::flags (), this),
  algorithm_ (algorithm, ::xml_schema::flags (), this)
{
}

params_t::
params_t (const params_t& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  dimension_ (x.dimension_, f, this),
  output_ (x.output_, f, this),
  iterationsperoutput_ (x.iterationsperoutput_, f, this),
  delta_t_ (x.delta_t_, f, this),
  t_end_ (x.t_end_, f, this),
  epsilon_ (x.epsilon_, f, this),
  sigma_ (x.sigma_, f, this),
  brownianMotionFactor_ (x.brownianMotionFactor_, f, this),
  gravity_ (x.gravity_, f, this),
  iterationsTillThermostatApplication_ (x.iterationsTillThermostatApplication_, f, this),
  initialTemperature_ (x.initialTemperature_, f, this),
  targetTemperature_ (x.targetTemperature_, f, this),
  temperatureStepSize_ (x.temperatureStepSize_, f, this),
  thermodynamicaldata_ (x.thermodynamicaldata_, f, this),
  t_start_ (x.t_start_, f, this),
  outputfmt_ (x.outputfmt_, f, this),
  potentialforce_ (x.potentialforce_, f, this),
  algorithm_ (x.algorithm_, f, this)
{
}

params_t::
params_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  dimension_ (f, this),
  output_ (f, this),
  iterationsperoutput_ (f, this),
  delta_t_ (f, this),
  t_end_ (f, this),
  epsilon_ (f, this),
  sigma_ (f, this),
  brownianMotionFactor_ (f, this),
  gravity_ (f, this),
  iterationsTillThermostatApplication_ (f, this),
  initialTemperature_ (f, this),
  targetTemperature_ (f, this),
  temperatureStepSize_ (f, this),
  thermodynamicaldata_ (f, this),
  t_start_ (f, this),
  outputfmt_ (f, this),
  potentialforce_ (f, this),
  algorithm_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void params_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // dimension
    //
    if (n.name () == "dimension" && n.namespace_ ().empty ())
    {
      if (!dimension_.present ())
      {
        this->dimension_.set (dimension_traits::create (i, f, this));
        continue;
      }
    }

    // output
    //
    if (n.name () == "output" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< output_type > r (
        output_traits::create (i, f, this));

      if (!output_.present ())
      {
        this->output_.set (r);
        continue;
      }
    }

    // iterationsperoutput
    //
    if (n.name () == "iterationsperoutput" && n.namespace_ ().empty ())
    {
      if (!iterationsperoutput_.present ())
      {
        this->iterationsperoutput_.set (iterationsperoutput_traits::create (i, f, this));
        continue;
      }
    }

    // delta_t
    //
    if (n.name () == "delta_t" && n.namespace_ ().empty ())
    {
      if (!delta_t_.present ())
      {
        this->delta_t_.set (delta_t_traits::create (i, f, this));
        continue;
      }
    }

    // t_end
    //
    if (n.name () == "t_end" && n.namespace_ ().empty ())
    {
      if (!t_end_.present ())
      {
        this->t_end_.set (t_end_traits::create (i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      if (!epsilon_.present ())
      {
        this->epsilon_.set (epsilon_traits::create (i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      if (!sigma_.present ())
      {
        this->sigma_.set (sigma_traits::create (i, f, this));
        continue;
      }
    }

    // brownianMotionFactor
    //
    if (n.name () == "brownianMotionFactor" && n.namespace_ ().empty ())
    {
      if (!this->brownianMotionFactor_)
      {
        this->brownianMotionFactor_.set (brownianMotionFactor_traits::create (i, f, this));
        continue;
      }
    }

    // gravity
    //
    if (n.name () == "gravity" && n.namespace_ ().empty ())
    {
      if (!this->gravity_)
      {
        this->gravity_.set (gravity_traits::create (i, f, this));
        continue;
      }
    }

    // iterationsTillThermostatApplication
    //
    if (n.name () == "iterationsTillThermostatApplication" && n.namespace_ ().empty ())
    {
      if (!this->iterationsTillThermostatApplication_)
      {
        this->iterationsTillThermostatApplication_.set (iterationsTillThermostatApplication_traits::create (i, f, this));
        continue;
      }
    }

    // initialTemperature
    //
    if (n.name () == "initialTemperature" && n.namespace_ ().empty ())
    {
      if (!this->initialTemperature_)
      {
        this->initialTemperature_.set (initialTemperature_traits::create (i, f, this));
        continue;
      }
    }

    // targetTemperature
    //
    if (n.name () == "targetTemperature" && n.namespace_ ().empty ())
    {
      if (!this->targetTemperature_)
      {
        this->targetTemperature_.set (targetTemperature_traits::create (i, f, this));
        continue;
      }
    }

    // temperatureStepSize
    //
    if (n.name () == "temperatureStepSize" && n.namespace_ ().empty ())
    {
      if (!this->temperatureStepSize_)
      {
        this->temperatureStepSize_.set (temperatureStepSize_traits::create (i, f, this));
        continue;
      }
    }

    // thermodynamicaldata
    //
    if (n.name () == "thermodynamicaldata" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< thermodynamicaldata_type > r (
        thermodynamicaldata_traits::create (i, f, this));

      if (!this->thermodynamicaldata_)
      {
        this->thermodynamicaldata_.set (r);
        continue;
      }
    }

    // t_start
    //
    if (n.name () == "t_start" && n.namespace_ ().empty ())
    {
      if (!t_start_.present ())
      {
        this->t_start_.set (t_start_traits::create (i, f, this));
        continue;
      }
    }

    // outputfmt
    //
    if (n.name () == "outputfmt" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< outputfmt_type > r (
        outputfmt_traits::create (i, f, this));

      if (!outputfmt_.present ())
      {
        this->outputfmt_.set (r);
        continue;
      }
    }

    // potentialforce
    //
    if (n.name () == "potentialforce" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< potentialforce_type > r (
        potentialforce_traits::create (i, f, this));

      if (!potentialforce_.present ())
      {
        this->potentialforce_.set (r);
        continue;
      }
    }

    // algorithm
    //
    if (n.name () == "algorithm" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< algorithm_type > r (
        algorithm_traits::create (i, f, this));

      if (!algorithm_.present ())
      {
        this->algorithm_.set (r);
        continue;
      }
    }

    break;
  }

  if (!dimension_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimension",
      "");
  }

  if (!output_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "output",
      "");
  }

  if (!iterationsperoutput_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "iterationsperoutput",
      "");
  }

  if (!delta_t_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "delta_t",
      "");
  }

  if (!t_end_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "t_end",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "epsilon",
      "");
  }

  if (!sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sigma",
      "");
  }

  if (!t_start_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "t_start",
      "");
  }

  if (!outputfmt_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "outputfmt",
      "");
  }

  if (!potentialforce_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "potentialforce",
      "");
  }

  if (!algorithm_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "algorithm",
      "");
  }
}

params_t* params_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class params_t (*this, f, c);
}

params_t::
~params_t ()
{
}

// particle_t
//

particle_t::
particle_t (const X_type& X,
            const V_type& V)
: ::xml_schema::type (),
  X_ (X, ::xml_schema::flags (), this),
  V_ (V, ::xml_schema::flags (), this),
  material_ (::xml_schema::flags (), this)
{
}

particle_t::
particle_t (const particle_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  V_ (x.V_, f, this),
  material_ (x.material_, f, this)
{
}

particle_t::
particle_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (f, this),
  V_ (f, this),
  material_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void particle_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // X
    //
    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_type > r (
        X_traits::create (i, f, this));

      if (!X_.present ())
      {
        this->X_.set (r);
        continue;
      }
    }

    // V
    //
    if (n.name () == "V" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_type > r (
        V_traits::create (i, f, this));

      if (!V_.present ())
      {
        this->V_.set (r);
        continue;
      }
    }

    // material
    //
    if (n.name () == "material" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< material_type > r (
        material_traits::create (i, f, this));

      if (!this->material_)
      {
        this->material_.set (r);
        continue;
      }
    }

    break;
  }

  if (!X_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "X",
      "");
  }

  if (!V_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V",
      "");
  }
}

particle_t* particle_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particle_t (*this, f, c);
}

particle_t::
~particle_t ()
{
}

// cuboid_t
//

cuboid_t::
cuboid_t (const X_type& X,
          const V_type& V,
          const N_type& N,
          const h_type& h)
: ::xml_schema::type (),
  X_ (X, ::xml_schema::flags (), this),
  V_ (V, ::xml_schema::flags (), this),
  N_ (N, ::xml_schema::flags (), this),
  h_ (h, ::xml_schema::flags (), this),
  material_ (::xml_schema::flags (), this)
{
}

cuboid_t::
cuboid_t (const cuboid_t& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  V_ (x.V_, f, this),
  N_ (x.N_, f, this),
  h_ (x.h_, f, this),
  material_ (x.material_, f, this)
{
}

cuboid_t::
cuboid_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (f, this),
  V_ (f, this),
  N_ (f, this),
  h_ (f, this),
  material_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void cuboid_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // X
    //
    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_type > r (
        X_traits::create (i, f, this));

      if (!X_.present ())
      {
        this->X_.set (r);
        continue;
      }
    }

    // V
    //
    if (n.name () == "V" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_type > r (
        V_traits::create (i, f, this));

      if (!V_.present ())
      {
        this->V_.set (r);
        continue;
      }
    }

    // N
    //
    if (n.name () == "N" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< N_type > r (
        N_traits::create (i, f, this));

      if (!N_.present ())
      {
        this->N_.set (r);
        continue;
      }
    }

    // h
    //
    if (n.name () == "h" && n.namespace_ ().empty ())
    {
      if (!h_.present ())
      {
        this->h_.set (h_traits::create (i, f, this));
        continue;
      }
    }

    // material
    //
    if (n.name () == "material" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< material_type > r (
        material_traits::create (i, f, this));

      if (!this->material_)
      {
        this->material_.set (r);
        continue;
      }
    }

    break;
  }

  if (!X_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "X",
      "");
  }

  if (!V_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V",
      "");
  }

  if (!N_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "N",
      "");
  }

  if (!h_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "h",
      "");
  }
}

cuboid_t* cuboid_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboid_t (*this, f, c);
}

cuboid_t::
~cuboid_t ()
{
}

// sphere_t
//

sphere_t::
sphere_t (const X_type& X,
          const V_type& V,
          const r_type& r,
          const h_type& h,
          const dimensions_type& dimensions)
: ::xml_schema::type (),
  X_ (X, ::xml_schema::flags (), this),
  V_ (V, ::xml_schema::flags (), this),
  r_ (r, ::xml_schema::flags (), this),
  h_ (h, ::xml_schema::flags (), this),
  dimensions_ (dimensions, ::xml_schema::flags (), this),
  material_ (::xml_schema::flags (), this)
{
}

sphere_t::
sphere_t (const sphere_t& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  V_ (x.V_, f, this),
  r_ (x.r_, f, this),
  h_ (x.h_, f, this),
  dimensions_ (x.dimensions_, f, this),
  material_ (x.material_, f, this)
{
}

sphere_t::
sphere_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (f, this),
  V_ (f, this),
  r_ (f, this),
  h_ (f, this),
  dimensions_ (f, this),
  material_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void sphere_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // X
    //
    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_type > r (
        X_traits::create (i, f, this));

      if (!X_.present ())
      {
        this->X_.set (r);
        continue;
      }
    }

    // V
    //
    if (n.name () == "V" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< V_type > r (
        V_traits::create (i, f, this));

      if (!V_.present ())
      {
        this->V_.set (r);
        continue;
      }
    }

    // r
    //
    if (n.name () == "r" && n.namespace_ ().empty ())
    {
      if (!r_.present ())
      {
        this->r_.set (r_traits::create (i, f, this));
        continue;
      }
    }

    // h
    //
    if (n.name () == "h" && n.namespace_ ().empty ())
    {
      if (!h_.present ())
      {
        this->h_.set (h_traits::create (i, f, this));
        continue;
      }
    }

    // dimensions
    //
    if (n.name () == "dimensions" && n.namespace_ ().empty ())
    {
      if (!dimensions_.present ())
      {
        this->dimensions_.set (dimensions_traits::create (i, f, this));
        continue;
      }
    }

    // material
    //
    if (n.name () == "material" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< material_type > r (
        material_traits::create (i, f, this));

      if (!this->material_)
      {
        this->material_.set (r);
        continue;
      }
    }

    break;
  }

  if (!X_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "X",
      "");
  }

  if (!V_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "V",
      "");
  }

  if (!r_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "r",
      "");
  }

  if (!h_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "h",
      "");
  }

  if (!dimensions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimensions",
      "");
  }
}

sphere_t* sphere_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sphere_t (*this, f, c);
}

sphere_t::
~sphere_t ()
{
}

// material_t
//

material_t::
material_t ()
: ::xml_schema::type (),
  name_ (::xml_schema::flags (), this),
  epsilon_ (::xml_schema::flags (), this),
  sigma_ (::xml_schema::flags (), this),
  mass_ (::xml_schema::flags (), this)
{
}

material_t::
material_t (const material_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  epsilon_ (x.epsilon_, f, this),
  sigma_ (x.sigma_, f, this),
  mass_ (x.mass_, f, this)
{
}

material_t::
material_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (f, this),
  epsilon_ (f, this),
  sigma_ (f, this),
  mass_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void material_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name_.set (r);
      continue;
    }

    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      this->epsilon_.set (epsilon_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      this->sigma_.set (sigma_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      this->mass_.set (mass_traits::create (i, f, this));
      continue;
    }
  }
}

material_t* material_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class material_t (*this, f, c);
}

material_t::
~material_t ()
{
}

// data_t
//

data_t::
data_t ()
: ::xml_schema::type (),
  particle_ (::xml_schema::flags (), this),
  inputfile_ (::xml_schema::flags (), this),
  cuboid_ (::xml_schema::flags (), this),
  sphere_ (::xml_schema::flags (), this),
  material_ (::xml_schema::flags (), this)
{
}

data_t::
data_t (const data_t& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  particle_ (x.particle_, f, this),
  inputfile_ (x.inputfile_, f, this),
  cuboid_ (x.cuboid_, f, this),
  sphere_ (x.sphere_, f, this),
  material_ (x.material_, f, this)
{
}

data_t::
data_t (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  particle_ (f, this),
  inputfile_ (f, this),
  cuboid_ (f, this),
  sphere_ (f, this),
  material_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void data_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // particle
    //
    if (n.name () == "particle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< particle_type > r (
        particle_traits::create (i, f, this));

      this->particle_.push_back (r);
      continue;
    }

    // inputfile
    //
    if (n.name () == "inputfile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< inputfile_type > r (
        inputfile_traits::create (i, f, this));

      this->inputfile_.push_back (r);
      continue;
    }

    // cuboid
    //
    if (n.name () == "cuboid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cuboid_type > r (
        cuboid_traits::create (i, f, this));

      this->cuboid_.push_back (r);
      continue;
    }

    // sphere
    //
    if (n.name () == "sphere" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< sphere_type > r (
        sphere_traits::create (i, f, this));

      this->sphere_.push_back (r);
      continue;
    }

    // material
    //
    if (n.name () == "material" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< material_type > r (
        material_traits::create (i, f, this));

      this->material_.push_back (r);
      continue;
    }

    break;
  }
}

data_t* data_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class data_t (*this, f, c);
}

data_t::
~data_t ()
{
}

// simulationfile_t
//

simulationfile_t::
simulationfile_t (const params_type& params,
                  const data_type& data)
: ::xml_schema::type (),
  params_ (params, ::xml_schema::flags (), this),
  data_ (data, ::xml_schema::flags (), this)
{
}

simulationfile_t::
simulationfile_t (::std::auto_ptr< params_type >& params,
                  ::std::auto_ptr< data_type >& data)
: ::xml_schema::type (),
  params_ (params, ::xml_schema::flags (), this),
  data_ (data, ::xml_schema::flags (), this)
{
}

simulationfile_t::
simulationfile_t (const simulationfile_t& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  params_ (x.params_, f, this),
  data_ (x.data_, f, this)
{
}

simulationfile_t::
simulationfile_t (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  params_ (f, this),
  data_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void simulationfile_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // params
    //
    if (n.name () == "params" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< params_type > r (
        params_traits::create (i, f, this));

      if (!params_.present ())
      {
        this->params_.set (r);
        continue;
      }
    }

    // data
    //
    if (n.name () == "data" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< data_type > r (
        data_traits::create (i, f, this));

      if (!data_.present ())
      {
        this->data_.set (r);
        continue;
      }
    }

    break;
  }

  if (!params_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "params",
      "");
  }

  if (!data_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "data",
      "");
  }
}

simulationfile_t* simulationfile_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulationfile_t (*this, f, c);
}

simulationfile_t::
~simulationfile_t ()
{
}

// condition
//

condition::
condition (const value_type& value)
: ::xml_schema::string (),
  value_ (value, ::xml_schema::flags (), this),
  type_ (::xml_schema::flags (), this)
{
}

condition::
condition (const char* _xsd_string_base,
           const value_type& value)
: ::xml_schema::string (_xsd_string_base),
  value_ (value, ::xml_schema::flags (), this),
  type_ (::xml_schema::flags (), this)
{
}

condition::
condition (const ::std::string& _xsd_string_base,
           const value_type& value)
: ::xml_schema::string (_xsd_string_base),
  value_ (value, ::xml_schema::flags (), this),
  type_ (::xml_schema::flags (), this)
{
}

condition::
condition (const ::xml_schema::string& _xsd_string_base,
           const value_type& value)
: ::xml_schema::string (_xsd_string_base),
  value_ (value, ::xml_schema::flags (), this),
  type_ (::xml_schema::flags (), this)
{
}

condition::
condition (const condition& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  value_ (x.value_, f, this),
  type_ (x.type_, f, this)
{
}

condition::
condition (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  value_ (f, this),
  type_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void condition::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value_type > r (
        value_traits::create (i, f, this));

      this->value_.set (r);
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      this->type_.set (r);
      continue;
    }
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "value",
      "");
  }
}

condition* condition::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class condition (*this, f, c);
}

condition::
~condition ()
{
}

// thermodynamicaldata
//

thermodynamicaldata::
thermodynamicaldata (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base,
                     const iterationsTillCalculation_type& iterationsTillCalculation)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base),
  iterationsTillCalculation_ (iterationsTillCalculation, ::xml_schema::flags (), this),
  iterationsPerCalculation_ (::xml_schema::flags (), this)
{
}

thermodynamicaldata::
thermodynamicaldata (const thermodynamicaldata& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c),
  iterationsTillCalculation_ (x.iterationsTillCalculation_, f, this),
  iterationsPerCalculation_ (x.iterationsPerCalculation_, f, this)
{
}

thermodynamicaldata::
thermodynamicaldata (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  iterationsTillCalculation_ (f, this),
  iterationsPerCalculation_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void thermodynamicaldata::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "iterationsTillCalculation" && n.namespace_ ().empty ())
    {
      this->iterationsTillCalculation_.set (iterationsTillCalculation_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "iterationsPerCalculation" && n.namespace_ ().empty ())
    {
      this->iterationsPerCalculation_.set (iterationsPerCalculation_traits::create (i, f, this));
      continue;
    }
  }

  if (!iterationsTillCalculation_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "iterationsTillCalculation",
      "");
  }
}

thermodynamicaldata* thermodynamicaldata::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class thermodynamicaldata (*this, f, c);
}

thermodynamicaldata::
~thermodynamicaldata ()
{
}

// outputfmt
//

outputfmt::
outputfmt (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_outputfmt_convert ();
}

outputfmt::
outputfmt (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_outputfmt_convert ();
}

outputfmt::
outputfmt (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_outputfmt_convert ();
}

outputfmt* outputfmt::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class outputfmt (*this, f, c);
}

outputfmt::value outputfmt::
_xsd_outputfmt_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_outputfmt_literals_);
  const value* i (::std::lower_bound (
                    _xsd_outputfmt_indexes_,
                    _xsd_outputfmt_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_outputfmt_indexes_ + 4 || _xsd_outputfmt_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const outputfmt::
_xsd_outputfmt_literals_[4] =
{
  "None",
  "VTK",
  "XYZ",
  "TXT"
};

const outputfmt::value outputfmt::
_xsd_outputfmt_indexes_[4] =
{
  ::outputfmt::None,
  ::outputfmt::TXT,
  ::outputfmt::VTK,
  ::outputfmt::XYZ
};

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::simulationfile_t >
simulationfile (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::simulationfile_t > r (
    ::simulationfile (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::simulationfile_t >
simulationfile (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::simulationfile_t > r (
    ::simulationfile (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::simulationfile_t >
simulationfile (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::simulationfile_t > r (
    ::simulationfile (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::simulationfile_t >
simulationfile (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulationfile (isrc, f, p);
}

::std::auto_ptr< ::simulationfile_t >
simulationfile (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulationfile (isrc, h, f, p);
}

::std::auto_ptr< ::simulationfile_t >
simulationfile (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulationfile (isrc, h, f, p);
}

::std::auto_ptr< ::simulationfile_t >
simulationfile (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulationfile (isrc, f, p);
}

::std::auto_ptr< ::simulationfile_t >
simulationfile (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulationfile (isrc, h, f, p);
}

::std::auto_ptr< ::simulationfile_t >
simulationfile (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulationfile (isrc, h, f, p);
}

::std::auto_ptr< ::simulationfile_t >
simulationfile (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::simulationfile_t > r (
    ::simulationfile (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::simulationfile_t >
simulationfile (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::simulationfile_t > r (
    ::simulationfile (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::simulationfile_t >
simulationfile (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::simulationfile_t > r (
    ::simulationfile (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::simulationfile_t >
simulationfile (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::simulationfile_t > r (
      ::simulationfile (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "simulationfile" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::simulationfile_t > r (
      ::xsd::cxx::tree::traits< ::simulationfile_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulationfile",
    "");
}

::std::auto_ptr< ::simulationfile_t >
simulationfile (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "simulationfile" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::simulationfile_t > r (
      ::xsd::cxx::tree::traits< ::simulationfile_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulationfile",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

